/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import type {EqualsFunction} from '@jest/expect-utils';
import type * as jestMatcherUtils from 'jest-matcher-utils';
import type {Tester} from '@jest/expect-utils';

export declare abstract class AsymmetricMatcher<T>
  implements AsymmetricMatcher_2
{
  protected sample: T;
  protected inverse: boolean;
  $$typeof: symbol;
  constructor(sample: T, inverse?: boolean);
  protected getMatcherContext(): MatcherContext;
  abstract asymmetricMatch(other: unknown): boolean;
  abstract toString(): string;
  getExpectedType?(): string;
  toAsymmetricMatcher?(): string;
}

declare type AsymmetricMatcher_2 = {
  asymmetricMatch(other: unknown): boolean;
  toString(): string;
  getExpectedType?(): string;
  toAsymmetricMatcher?(): string;
};

export declare interface AsymmetricMatchers {
  any(sample: unknown): AsymmetricMatcher_2;
  anything(): AsymmetricMatcher_2;
  arrayContaining(sample: Array<unknown>): AsymmetricMatcher_2;
  closeTo(sample: number, precision?: number): AsymmetricMatcher_2;
  objectContaining(sample: Record<string, unknown>): AsymmetricMatcher_2;
  stringContaining(sample: string): AsymmetricMatcher_2;
  stringMatching(sample: string | RegExp): AsymmetricMatcher_2;
}

declare type AsyncExpectationResult = Promise<SyncExpectationResult>;

export declare interface BaseExpect {
  assertions(numberOfAssertions: number): void;
  extend(matchers: MatchersObject): void;
  extractExpectedAssertionsErrors(): ExpectedAssertionsErrors;
  getState(): MatcherState;
  hasAssertions(): void;
  setState(state: Partial<MatcherState>): void;
}

export declare type Expect = {
  <T = unknown>(actual: T): Matchers<void> &
    Inverse<Matchers<void>> &
    PromiseMatchers;
} & BaseExpect &
  AsymmetricMatchers &
  Inverse<Omit<AsymmetricMatchers, 'any' | 'anything'>>;

declare const expect_2: Expect;
export default expect_2;
export {expect_2 as expect};

export declare type ExpectationResult =
  | SyncExpectationResult
  | AsyncExpectationResult;

declare type ExpectedAssertionsErrors = Array<{
  actual: string | number;
  error: Error;
  expected: string;
}>;

declare type Inverse<Matchers> = {
  /**
   * Inverse next matcher. If you know how to test something, `.not` lets you test its opposite.
   */
  not: Matchers;
};

export declare class JestAssertionError extends Error {
  matcherResult?: Omit<SyncExpectationResult, 'message'> & {
    message: string;
  };
}

export declare type MatcherContext = MatcherUtils & Readonly<MatcherState>;

export declare type MatcherFunction<Expected extends Array<unknown> = []> =
  MatcherFunctionWithContext<MatcherContext, Expected>;

export declare type MatcherFunctionWithContext<
  Context extends MatcherContext = MatcherContext,
  Expected extends Array<any> = [] /** TODO should be: extends Array<unknown> = [] */,
> = (
  this: Context,
  actual: unknown,
  ...expected: Expected
) => ExpectationResult;

export declare interface Matchers<R extends void | Promise<void>> {
  /**
   * Ensures the last call to a mock function was provided specific args.
   */
  