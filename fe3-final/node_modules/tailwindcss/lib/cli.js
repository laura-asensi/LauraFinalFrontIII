#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _indexJs = require("../peers/index.js");
const _chokidar = /*#__PURE__*/ _interopRequireDefault(require("chokidar"));
const _path = /*#__PURE__*/ _interopRequireDefault(require("path"));
const _arg = /*#__PURE__*/ _interopRequireDefault(require("arg"));
const _fs = /*#__PURE__*/ _interopRequireDefault(require("fs"));
const _postcssLoadConfig = /*#__PURE__*/ _interopRequireDefault(require("postcss-load-config"));
const _lilconfig = require("lilconfig");
const _plugins = /*#__PURE__*/ _interopRequireDefault(require("postcss-load-config/src/plugins" // Little bit scary, looking at private/internal API
));
const _options = /*#__PURE__*/ _interopRequireDefault(require("postcss-load-config/src/options" // Little bit scary, looking at private/internal API
));
const _processTailwindFeatures = /*#__PURE__*/ _interopRequireDefault(require("./processTailwindFeatures"));
const _resolveConfig = /*#__PURE__*/ _interopRequireDefault(require("../resolveConfig"));
const _fastGlob = /*#__PURE__*/ _interopRequireDefault(require("fast-glob"));
const _getModuleDependencies = /*#__PURE__*/ _interopRequireDefault(require("./lib/getModuleDependencies"));
const _log = /*#__PURE__*/ _interopRequireDefault(require("./util/log"));
const _packageJson = /*#__PURE__*/ _interopRequireDefault(require("../package.json"));
const _normalizePath = /*#__PURE__*/ _interopRequireDefault(require("normalize-path"));
const _validateConfigJs = require("./util/validateConfig.js");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let env = {
    DEBUG: process.env.DEBUG !== undefined && process.env.DEBUG !== "0"
};
function isESM() {
    const pkgPath = _path.default.resolve("./package.json");
    try {
        let pkg = JSON.parse(_fs.default.readFileSync(pkgPath, "utf8"));
        return pkg.type && pkg.type === "module";
    } catch (err) {
        return false;
    }
}
let configs = isESM() ? {
    tailwind: "tailwind.config.cjs",
    postcss: "postcss.config.cjs"
} : {
    tailwind: "tailwind.config.js",
    postcss: "postcss.config.js"
};
// ---
function indentRecursive(node, indent = 0) {
    node.each && node.each((child, i)=>{
        if (!child.raws.before || !child.raws.before.trim() || child.raws.before.includes("\n")) {
            child.raws.before = `\n${node.type !== "rule" && i > 0 ? "\n" : ""}${"  ".repeat(indent)}`;
        }
        child.raws.after = `\n${"  ".repeat(indent)}`;
        indentRecursive(child, indent + 1);
    });
}
function formatNodes(root) {
    indentRecursive(root);
    if (root.first) {
        root.first.raws.before = "";
    }
}
async function outputFile(file, contents) {
    if (_fs.default.existsSync(file) && await _fs.default.promises.readFile(file, "utf8") === contents) {
        return; // Skip writing the file
    }
    // Write the file
    await _fs.default.promises.writeFile(file, contents, "utf8");
}
function drainStdin() {
    return new Promise((resolve, reject)=>{
        let result = "";
        process.stdin.on("data", (chunk)=>{
            result += chunk;
        });
        process.stdin.on("end", ()=>resolve(result));
        process.stdin.on("error", (err)=>reject(err));
    });
}
function help({ message , usage , commands , options  }) {
    let indent = 2;
    // Render header
    console.log();
    console.log(`${_packageJson.default.name} v${_packageJson.default.version}`);
    // Render message
    if (message) {
        console.log();
        for (let msg of message.split("\n")){
            console.log(msg);
        }
    }
    // Render usage
    if (usage && usage.length > 0) {
        console.log();
        console.log("Usage:");
        for (let example of usage){
            console.log(" ".repeat(indent), example);
        }
    }
    // Render commands
    if (commands && commands.length > 0) {
        console.log();
        console.log("Commands:");
        for (let command of commands){
            console.log(" ".repeat(indent), command);
        }
    }
    // Render options
    if (options) {
        let groupedOptions = {};
        for (let [key, value] of Object.entries(options)){
            if (typeof value === "object") {
                groupedOptions[key] = {
                    ...value,
                    flags: [
                        key
                    ]
                };
            } else {
                groupedOptions[value].flags.push(key);
            }
        }
        console.log();
        console.log("Options:");
        for (let { flags , description , deprecated  } of Object.values(groupedOptions)){
            if (deprecated) continue;
            if (flags.length === 1) {
                console.log(" ".repeat(indent + 4 /* 4 = "-i, ".length */ ), flags.slice().reverse().join(", ").padEnd(20, " "), description);
            } else {
                console.log(" ".repeat(indent), flags.slice().reverse().join(", ").padEnd(24, " "), description);
            }
        }
    }
    console.log();
}
function oneOf(...options) {
    return Object.assign((value = true)=>{
        for (let option of options){
            let parsed = option(value);
            if (parsed === value) {
                return parsed;
            }
        }
        throw new Error("...");
    }, {
        manualParsing: true
    });
}
function loadPostcss() {
    // Try to load a local `postcss` version first
    try {
        return require("postcss");
    } catch  {}
    return (0, _indexJs.lazyPostcss)();
}
let commands = {
    init: {
        run: init,
        args: {
            "--full": {
                type: Boolean,
                description: `Initialize a full \`${configs.tailwind}\` file`
            },
            "--postcss": {
                type: Boolean,
                description: `Initialize a \`${configs.postcss}\` file`
            },
            "-f": "--full",
            "-p": "--postcss"
        }
    },
    build: {
        run: build,
        args: {
            "--input": {
                type: String,
                description: "Input file"
            },
            "--output": {
                type: String,
                description: "Output file"
            },
            "--watch": {
                type: Boolean,
                description: "Watch for changes and rebuild as needed"
            },
            "--poll": {
                type: Boolean,
                description: "Use polling instead of filesystem events when watching"
            },
            "--content": {
                type: String,
                description: "Content paths to use for removing unused classes"
            },
            "--purge": {
                type: String,
                deprecated: true
            },
            "--postcss": {
                type: oneOf(String, Boolean),
                description: "Load custom PostCSS configuration"
            },
            "--minify": {
                type: Boolean,
                description: "Minify the output"
            },
            "--config": {
                type: String,
                description: "Path to a custom config file"
            },
            "--no-autoprefixer": {
                type: Boolean,
                description: "Disable autoprefixer"
            },
            "-c": "--config",
            "-i": "--input",
            "-o": "--output",
            "-m": "--minify",
            "-w": "--watch",
            "-p": "--poll"
        }
    }
};
let sharedFlags = {
    "--help": {
        type: Boolean,
        description: "Display usage information"
    },
    "-h": "--help"
};
if (process.stdout.isTTY /* Detect redirecting output to a file */  && (process.argv[2] === undefined || process.argv.slice(2).every((flag)=>sharedFlags[flag] !== undefined))) {
    help({
        usage: [
            "tailwindcss [--input input.css] [--output output.css] [--watch] [options...]",
            "tailwindcss init [--full] [--postcss] [options...]", 
        ],
        commands: Object.keys(commands).filter((command)=>command !== "build").map((command)=>`${command} [options]`),
        options: {
            ...commands.build.args,
            ...sharedFlags
        }
    });
    process.exit(0);
}
let command = ((arg = "")=>arg.startsWith("-") ? undefined : arg)(process.argv[2]) || "build";
if (commands[command] === undefined) {
    if (_fs.default.existsSync(_path.default.resolve(command))) {
        // TODO: Deprecate this in future versions
        // Check if non-existing command, might be a file.
        command = "build";
    } else {
        help({
            message: `Invalid command: ${command}`,
            usage: [
                "tailwindcss <command> [options]"
            ],
            commands: Object.keys(commands).filter((command)=>command !== "build").map((command)=>`${command} [options]`),
            options: sharedFlags
        });
        process.exit(1);
    }
}
// Execute command
let { args: flags , run  } = commands[command];
let args = (()=>{
    try {
        let result = (0, _arg.default)(Object.fromEntries(Object.entries({
            ...flags,
            ...sharedFlags
        }).filter(([_key, value])=>{
            var ref;
            return !(value === null || value === void 0 ? void 0 : (ref = value.type) === null || ref === void 0 ? void 0 : ref.manualParsing);
        }).map(([key, value])=>[
                key,
                typeof value === "object" ? value.type : value
            ])), {
            permissive: true
        });
        // Manual parsing of flags to allow for special flags like oneOf(Boolean, String)
        